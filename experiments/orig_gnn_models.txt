chebyshev.py

normalize function. 
 It takes a sparse matrix L and returns a normalized version.
 The half_interval parameter probably determines how it's normalized. 
 The comments mention "half_interval" and "else" part. Let me see: if half_interval is True, 
 they multiply L by 1.0/topeig. Otherwise, multiply by 2.0/topeig and subtract the identity matrix 
 from the diagonal. Oh right, Chebyshev polynomials often require the eigenvalues to be 
 in a certain interval. So maybe this is scaling the Laplacian matrix so that its eigenvalues 
 are within [-1,1] or [0,2], depending on the normalization. 


Changes: 
1. Dynamic Laplacian Handling: Each graph’s Laplacians are computed on-the-fly during training, ensuring compatibility with varying mesh structures.
2. Explicit Feature Separation: Decouples MP-PDE’s general graph processing from SCNN’s simplicial requirements.
3. Backward Compatibility: Non-SCNN models (e.g., baseline MP-PDE) continue using the original graph-based forward pass.

